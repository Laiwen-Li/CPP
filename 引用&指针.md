###### 引用&指针

1. 引用

引用(***reference***)为对象起了另外一个名字，引用类型引用(***refers to***)另外一种类型。通过将声明符写成**&d**的形式来定义引用类型型,其中**d**是声明的变量名。在初始化变量时，会出现初始值拷贝现象，定义引用则将引用与初始值对象绑定在一起。

* 引用必须初始化（类型必须严格匹配）

* 引用并不是对象，而是给一个已经存在的对象起另一个名字（这个对象必须存在，不可为字面值[10,"10"...]）

  ```cpp
  int &refVal  = 0;            //error
  
  double dval  = 3.14;
  int &refVal2 = dval;         //error
  ```

  

2. 指针

指针(***pointer***)是'”指向(***point to***)“另外一种类型型的复合类型。定义指针类型的方法将声明符写成***d**的形式,其中**d**是变量名。

* 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。

* 指针无须在定义时赋初值。

使用取地址符（**&**）可以取得存放某个对象的地址。

* 类型必须严格匹配

```cpp
double dval = 3.14;
int *p = &dval;
```

指针的值(即地址)应属下列4种状态之一:
* 指向一个对象。
* 指向紧邻对象所占空间的下一个位置。
* 空指针,意味着指针没有指向任何对象。
* 无效指针,也就是上述情况之外的其他值。

**利用指针访问对象**

如果指针指向了一个对象，则可以用解引用符（*****）来访问该对象。

```cpp
int ival = 42;
int *p = &ival;  //声明指针

*p = 0;          //改变对象内容
cout<< *p;       //输出0
```

* 解引用符只适用于确指向了某个对象的有效指针



3. 空指针

空指针不指向任何对象，在试图使用一个指针之前可以检查其是否为空。

```cpp
int *p1 = nullptr;  //C++11
int *p2 = 0;
int *p3 = NULL;     //cstdlib
```



4. void* 指针

**void ***是一种特殊的指针类型，可用于存放任意对象的地址。存放的也仅仅就是一个地址。

```cpp
double obj = 3.14;
void *pv = &obj;
```

* 不能直接操作相关void *所指向的对象。

---

1. 指向指针的指针

通过*的个数区分指针的级别。

```cpp
int ival = 1024;
int *pi = &ival;  //指向int
int **ppi = &pi;  //指向一个int指针
```

2. 指向指针的引用

引用不是对象，指针是对象，因此不存在指向引用的指针，只存在指向指针的引用。

```cpp
int i = 42;
int *p;
int *&r = p;  //对int指针的引用

r = &i;       //r是一个int指针，即r指向i
*r = 0;       //解引用r得到i
```

**如何理解r的类型是什么？**

从右往左阅读，越靠近r的对r有最直接影响（*&r -> & -> r为一个指针）